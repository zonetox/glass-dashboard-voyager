interface StandardizedSEOAnalysis {
  metaTitle: {
    length: number;
    status: 'optimal' | 'too_short' | 'too_long' | 'missing';
    keywordPresence: boolean;
    current: string;
    suggestion: string;
  };
  metaDescription: {
    length: number;
    status: 'optimal' | 'too_short' | 'too_long' | 'missing';
    unique: boolean;
    hasCTA: boolean;
    current: string;
    suggestion: string;
  };
  headings: {
    total: number;
    h1Count: number;
    h2Count: number;
    h3Count: number;
    duplicates: number;
    missing: string[];
    structureScore: number;
    suggestions: string[];
  };
  altText: {
    totalImages: number;
    missingAlt: number;
    withAlt: number;
    keywordMatch: number;
    suggestions: string[];
  };
  pageSpeed: {
    mobile: {
      score: number;
      status: 'good' | 'needs_improvement' | 'poor';
    };
    desktop: {
      score: number;
      status: 'good' | 'needs_improvement' | 'poor';
    };
    criticalIssues: string[];
    detailedSuggestions: {
      images: string[];
      javascript: string[];
      css: string[];
      fonts: string[];
    };
  };
  schema: {
    type: string;
    status: 'found' | 'missing' | 'invalid';
    validation: 'pass' | 'fail';
    suggestions: string[];
    autoGeneratedSchema?: any;
  };
  internalLinks: {
    totalLinks: number;
    orphanedPages: number;
    linkSuggestions: Array<{
      fromPage: string;
      toPage: string;
      anchorText: string;
      relevanceScore: number;
    }>;
    anchorTextOptimization: string[];
  };
  overall: {
    seoScore: number;
    priorityActions: string[];
    nextOptimizationTarget: string;
  };
}

export class StandardizedSEOAnalyzer {
  private targetKeywords: string[] = [];
  
  constructor(keywords: string[] = []) {
    this.targetKeywords = keywords.map(k => k.toLowerCase());
  }

  public analyzeWithStandardFormat(analysisData: any): StandardizedSEOAnalysis {
    return {
      metaTitle: this.analyzeMetaTitle(analysisData),
      metaDescription: this.analyzeMetaDescription(analysisData),
      headings: this.analyzeHeadings(analysisData),
      altText: this.analyzeAltText(analysisData),
      pageSpeed: this.analyzePageSpeed(analysisData),
      schema: this.analyzeSchema(analysisData),
      internalLinks: this.analyzeInternalLinks(analysisData),
      overall: this.calculateOverallAnalysis(analysisData)
    };
  }

  private analyzeMetaTitle(data: any) {
    const title = data.title || '';
    const length = title.length;
    let status: 'optimal' | 'too_short' | 'too_long' | 'missing' = 'missing';
    
    if (!title) {
      status = 'missing';
    } else if (length < 30) {
      status = 'too_short';
    } else if (length > 60) {
      status = 'too_long';
    } else {
      status = 'optimal';
    }

    const keywordPresence = this.targetKeywords.some(keyword => 
      title.toLowerCase().includes(keyword)
    );

    const suggestion = this.generateTitleSuggestion(title, data);

    return {
      length,
      status,
      keywordPresence,
      current: title,
      suggestion
    };
  }

  private analyzeMetaDescription(data: any) {
    const description = data.metaDescription || '';
    const length = description.length;
    let status: 'optimal' | 'too_short' | 'too_long' | 'missing' = 'missing';
    
    if (!description) {
      status = 'missing';
    } else if (length < 120) {
      status = 'too_short';
    } else if (length > 160) {
      status = 'too_long';
    } else {
      status = 'optimal';
    }

    const unique = true; // Would need database comparison for real uniqueness check
    const hasCTA = /\b(click|learn|discover|get|try|start|buy|download|read)\b/i.test(description);
    const suggestion = this.generateDescriptionSuggestion(description, data);

    return {
      length,
      status,
      unique,
      hasCTA,
      current: description,
      suggestion
    };
  }

  private analyzeHeadings(data: any) {
    const headings = data.headings || { h1: [], h2: [], h3: [] };
    const h1Count = headings.h1?.length || 0;
    const h2Count = headings.h2?.length || 0;
    const h3Count = headings.h3?.length || 0;
    const total = h1Count + h2Count + h3Count;

    // Find duplicates
    const allHeadings = [
      ...(headings.h1 || []),
      ...(headings.h2 || []),
      ...(headings.h3 || [])
    ];
    const duplicates = allHeadings.length - new Set(allHeadings.map(h => h.toLowerCase())).size;

    // Check for missing structure elements
    const missing = [];
    if (h1Count === 0) missing.push('H1 tag');
    if (h1Count > 1) missing.push('Multiple H1 tags (should be only one)');
    if (h2Count === 0 && total > 1) missing.push('H2 tags for content structure');
    if (h3Count > 0 && h2Count === 0) missing.push('H2 tags before H3 tags');

    // Calculate structure score
    let structureScore = 100;
    if (h1Count === 0) structureScore -= 30;
    if (h1Count > 1) structureScore -= 20;
    if (duplicates > 0) structureScore -= duplicates * 10;
    if (h2Count === 0 && total > 3) structureScore -= 15;
    structureScore = Math.max(0, structureScore);

    const suggestions = this.generateHeadingSuggestions(headings, missing);

    return {
      total,
      h1Count,
      h2Count,
      h3Count,
      duplicates,
      missing,
      structureScore,
      suggestions
    };
  }

  private analyzeAltText(data: any) {
    const images = data.images || { total: 0, missingAlt: 0, withAlt: 0 };
    const totalImages = images.total || 0;
    const missingAlt = images.missingAlt || 0;
    const withAlt = images.withAlt || 0;

    // Estimate keyword match (would need actual alt text analysis)
    const keywordMatch = Math.max(0, withAlt - Math.floor(withAlt * 0.7));

    const suggestions = this.generateAltTextSuggestions(images);

    return {
      totalImages,
      missingAlt,
      withAlt,
      keywordMatch,
      suggestions
    };
  }

  private analyzePageSpeed(data: any) {
    const pageSpeed = data.pageSpeedInsights || {};
    const mobile = pageSpeed.mobile || { score: 0 };
    const desktop = pageSpeed.desktop || { score: 0 };

    const getStatus = (score: number): 'good' | 'needs_improvement' | 'poor' => {
      if (score >= 90) return 'good';
      if (score >= 50) return 'needs_improvement';
      return 'poor';
    };

    const criticalIssues = [];
    if (mobile.score < 50) criticalIssues.push('Poor mobile performance');
    if (desktop.score < 50) criticalIssues.push('Poor desktop performance');
    if (mobile.lcp > 2500) criticalIssues.push('Slow Largest Contentful Paint');
    if (mobile.cls > 0.1) criticalIssues.push('High Cumulative Layout Shift');

    const detailedSuggestions = {
      images: [
        'Optimize images with WebP format',
        'Implement lazy loading for images',
        'Compress images without quality loss'
      ],
      javascript: [
        'Minify JavaScript files',
        'Remove unused JavaScript',
        'Use code splitting for large bundles'
      ],
      css: [
        'Minify CSS files',
        'Remove unused CSS',
        'Inline critical CSS'
      ],
      fonts: [
        'Use font-display: swap',
        'Preload important fonts',
        'Optimize font loading strategy'
      ]
    };

    return {
      mobile: {
        score: mobile.score || 0,
        status: getStatus(mobile.score || 0)
      },
      desktop: {
        score: desktop.score || 0,
        status: getStatus(desktop.score || 0)
      },
      criticalIssues,
      detailedSuggestions
    };
  }

  private analyzeSchema(data: any) {
    const schema = data.schemaMarkup || {};
    const type = schema.type || 'WebPage';
    const hasSchema = !!schema.jsonLd;
    
    let status: 'found' | 'missing' | 'invalid' = hasSchema ? 'found' : 'missing';
    let validation: 'pass' | 'fail' = 'pass';

    if (hasSchema) {
      // Basic validation check
      try {
        if (!schema.jsonLd['@context'] || !schema.jsonLd['@type']) {
          status = 'invalid';
          validation = 'fail';
        }
      } catch {
        status = 'invalid';
        validation = 'fail';
      }
    }

    const suggestions = this.generateSchemaSuggestions(data, status);

    return {
      type,
      status,
      validation,
      suggestions,
      autoGeneratedSchema: hasSchema ? schema.jsonLd : this.generateAutoSchema(data)
    };
  }

  private analyzeInternalLinks(data: any) {
    // This would typically require a full site crawl
    // For now, we'll provide estimates based on available data
    const totalLinks = 0; // Would be calculated from crawl data
    const orphanedPages = 0; // Would be calculated from site structure

    const linkSuggestions = [
      {
        fromPage: data.url || '',
        toPage: '/related-content',
        anchorText: this.targetKeywords[0] || 'relevant keyword',
        relevanceScore: 85
      }
    ];

    const anchorTextOptimization = [
      'Use descriptive anchor text instead of "click here"',
      'Include target keywords in anchor text naturally',
      'Vary anchor text for similar linked content'
    ];

    return {
      totalLinks,
      orphanedPages,
      linkSuggestions,
      anchorTextOptimization
    };
  }

  private calculateOverallAnalysis(data: any) {
    let seoScore = 100;
    
    // Title analysis impact
    if (!data.title) seoScore -= 20;
    else if (data.title.length < 30 || data.title.length > 60) seoScore -= 10;
    
    // Meta description impact
    if (!data.metaDescription) seoScore -= 15;
    else if (data.metaDescription.length < 120 || data.metaDescription.length > 160) seoScore -= 8;
    
    // Headings impact
    const headings = data.headings || { h1: [], h2: [], h3: [] };
    if (headings.h1?.length === 0) seoScore -= 15;
    if (headings.h1?.length > 1) seoScore -= 10;
    
    // Images impact
    const images = data.images || { total: 0, missingAlt: 0 };
    if (images.missingAlt > 0) {
      seoScore -= Math.min(15, images.missingAlt * 2);
    }
    
    // PageSpeed impact
    const pageSpeed = data.pageSpeedInsights;
    if (pageSpeed) {
      const avgSpeed = (pageSpeed.mobile.score + pageSpeed.desktop.score) / 2;
      if (avgSpeed < 50) seoScore -= 20;
      else if (avgSpeed < 80) seoScore -= 10;
    }

    seoScore = Math.max(0, Math.min(100, seoScore));

    const priorityActions = this.getPriorityActions(data, seoScore);
    const nextOptimizationTarget = this.getNextOptimizationTarget(data);

    return {
      seoScore,
      priorityActions,
      nextOptimizationTarget
    };
  }

  // Helper methods for generating suggestions
  private generateTitleSuggestion(currentTitle: string, data: any): string {
    if (!currentTitle) {
      const keyword = this.targetKeywords[0] || 'your main keyword';
      return `${keyword} - Complete Guide | Your Brand`;
    }
    
    if (currentTitle.length < 30) {
      return `${currentTitle} - Complete Guide`;
    }
    
    if (currentTitle.length > 60) {
      return currentTitle.substring(0, 57) + '...';
    }
    
    return currentTitle;
  }

  private generateDescriptionSuggestion(currentDesc: string, data: any): string {
    if (!currentDesc) {
      const keyword = this.targetKeywords[0] || 'your topic';
      return `Discover everything about ${keyword}. Get expert insights, practical tips, and actionable advice. Start optimizing today!`;
    }
    
    if (currentDesc.length < 120) {
      return `${currentDesc} Get expert insights and practical tips. Start optimizing today!`;
    }
    
    if (currentDesc.length > 160) {
      return currentDesc.substring(0, 157) + '...';
    }
    
    return currentDesc;
  }

  private generateHeadingSuggestions(headings: any, missing: string[]): string[] {
    const suggestions = [];
    
    if (missing.includes('H1 tag')) {
      suggestions.push('Add a single, descriptive H1 tag with your main keyword');
    }
    
    if (missing.includes('H2 tags for content structure')) {
      suggestions.push('Structure content with H2 tags for main sections');
    }
    
    if (headings.h1?.length > 1) {
      suggestions.push('Use only one H1 tag per page');
    }
    
    suggestions.push('Ensure heading hierarchy follows logical order (H1 > H2 > H3)');
    suggestions.push('Include relevant keywords in headings naturally');
    
    return suggestions;
  }

  private generateAltTextSuggestions(images: any): string[] {
    const suggestions = [];
    
    if (images.missingAlt > 0) {
      suggestions.push(`Add descriptive alt text to ${images.missingAlt} images`);
      suggestions.push('Include main keyword in 1-2 alt texts naturally');
      suggestions.push('Use secondary keywords in other image alt texts');
    }
    
    suggestions.push('Describe image content accurately for accessibility');
    suggestions.push('Keep alt text under 125 characters');
    
    return suggestions;
  }

  private generateSchemaSuggestions(data: any, status: string): string[] {
    const suggestions = [];
    
    if (status === 'missing') {
      suggestions.push('Add schema.org structured data for better search visibility');
      suggestions.push('Implement Article or BlogPosting schema for content pages');
    }
    
    if (status === 'invalid') {
      suggestions.push('Fix schema markup validation errors');
      suggestions.push('Ensure required properties are included');
    }
    
    suggestions.push('Consider adding FAQ schema for common questions');
    suggestions.push('Add Organization schema for brand recognition');
    
    return suggestions;
  }

  private generateAutoSchema(data: any): any {
    return {
      "@context": "https://schema.org",
      "@type": "WebPage",
      "name": data.title || "Untitled Page",
      "description": data.metaDescription || "Page description",
      "url": data.url
    };
  }

  private getPriorityActions(data: any, seoScore: number): string[] {
    const actions = [];
    
    if (!data.title) actions.push('Add page title immediately');
    if (!data.metaDescription) actions.push('Write compelling meta description');
    if (!data.headings?.h1?.length) actions.push('Add H1 heading');
    if (data.images?.missingAlt > 0) actions.push('Add alt text to images');
    
    const pageSpeed = data.pageSpeedInsights;
    if (pageSpeed && (pageSpeed.mobile.score < 50 || pageSpeed.desktop.score < 50)) {
      actions.push('Fix critical performance issues');
    }
    
    return actions.slice(0, 3); // Top 3 priority actions
  }

  private getNextOptimizationTarget(data: any): string {
    if (!data.title) return 'Page Title Optimization';
    if (!data.metaDescription) return 'Meta Description';
    if (!data.headings?.h1?.length) return 'Content Structure (H1)';
    if (data.images?.missingAlt > 0) return 'Image Alt Text';
    
    const pageSpeed = data.pageSpeedInsights;
    if (pageSpeed && pageSpeed.mobile.score < 80) return 'Mobile Performance';
    if (pageSpeed && pageSpeed.desktop.score < 80) return 'Desktop Performance';
    
    return 'Internal Linking Strategy';
  }

  public formatAnalysisOutput(analysis: StandardizedSEOAnalysis): string {
    const lines = [];
    
    // Meta Title
    lines.push(`✅ Meta Title: ${analysis.metaTitle.length} ký tự – ${analysis.metaTitle.status} – keyword: ${analysis.metaTitle.keywordPresence ? 'yes' : 'no'}`);
    if (analysis.metaTitle.suggestion !== analysis.metaTitle.current) {
      lines.push(`   💡 Đề xuất: ${analysis.metaTitle.suggestion}`);
    }
    
    // Meta Description
    lines.push(`✅ Meta Description: ${analysis.metaDescription.length} ký tự – ${analysis.metaDescription.status} – unique: ${analysis.metaDescription.unique}`);
    if (analysis.metaDescription.suggestion !== analysis.metaDescription.current) {
      lines.push(`   💡 Đề xuất: ${analysis.metaDescription.suggestion}`);
    }
    
    // Headings
    lines.push(`✅ Headings (H1-H3): ${analysis.headings.total} total – trùng: ${analysis.headings.duplicates} – thiếu: ${analysis.headings.missing.length}`);
    if (analysis.headings.suggestions.length > 0) {
      lines.push(`   💡 Gợi ý: ${analysis.headings.suggestions[0]}`);
    }
    
    // Alt Text
    lines.push(`✅ Alt Text: ${analysis.altText.totalImages} images – thiếu alt: ${analysis.altText.missingAlt} – keyword match: ${analysis.altText.keywordMatch}`);
    if (analysis.altText.suggestions.length > 0) {
      lines.push(`   💡 Gợi ý: ${analysis.altText.suggestions[0]}`);
    }
    
    // PageSpeed
    lines.push(`✅ PageSpeed: Mobile: ${analysis.pageSpeed.mobile.score}/100 – Desktop: ${analysis.pageSpeed.desktop.score}/100`);
    if (analysis.pageSpeed.criticalIssues.length > 0) {
      lines.push(`   ⚠️ Lỗi: ${analysis.pageSpeed.criticalIssues[0]}`);
    }
    
    // Schema
    lines.push(`✅ Schema: ${analysis.schema.type}: ${analysis.schema.status} – validate: ${analysis.schema.validation}`);
    if (analysis.schema.suggestions.length > 0) {
      lines.push(`   💡 Gợi ý: ${analysis.schema.suggestions[0]}`);
    }
    
    // Internal Links
    lines.push(`✅ Internal Links: ${analysis.internalLinks.totalLinks} – orphaned pages: ${analysis.internalLinks.orphanedPages}`);
    if (analysis.internalLinks.linkSuggestions.length > 0) {
      const suggestion = analysis.internalLinks.linkSuggestions[0];
      lines.push(`   💡 Gợi ý: Link tới "${suggestion.toPage}" với anchor "${suggestion.anchorText}"`);
    }
    
    lines.push('');
    lines.push(`🎯 SEO Score: ${analysis.overall.seoScore}/100`);
    lines.push(`🚀 Hành động ưu tiên: ${analysis.overall.priorityActions.join(', ')}`);
    lines.push(`📈 Tối ưu tiếp theo: ${analysis.overall.nextOptimizationTarget}`);
    
    return lines.join('\n');
  }
}